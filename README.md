# Практична робота за другий курс

## Меню

### Опис

Дане вікно можна розділити на три частини: меню (зліва), панель для взаємодії (зверху) та панель в якій будуть виводитися форма вибраного пункту меню.

![](https://github.com/BogdanPhoenix/Practica_Course2/raw/master/Images/Menu.png "Головне меню")

Після запуску програми, користувач може обрати один із запропонованих пунктів меню (перший пункт є активним при запуску програми). Перед користувачем при першому запуску буде відображатися меню у прихованому вигляді. Щоб відкрити його, потрібно натиснути на відповідну кнопку у верхньому лівому куті програми.

Щоб змінити форму або оновити активну потрібно натиснути на відповідний пункт меню. Після натиску на кнопку виконується метод [ActivateButton](/Practice/UserProfile.cs). В активної кнопка номер задачі переміщується на праву сторону, а з лівої сторони з'являється оранжева смужка, яка символізує активний пункт.

Після натиску на один із пунктів також викликається метод [DisableButton](/Practice/UserProfile.cs), який надає кнопці стандартного вигляду, і присвоює локальній змінній силку на об'єкт нової активованої кнопки.

Якщо користувач натиснув на активну кнопку іще раз, то бідбудеться очищення всього змісту на формі (форма прийме дефолтний вигляд).

```c#
/// <param name="sender">Об'єкт активованої кнопки</param>
private void ActivateButton(object sender)
{
    if (currentChildForm != null)
    {
        currentChildForm.Close();
    }
    if (sender != null && (BunifuButton2)sender != currentBtn)
    {
        DisableButton();

        currentBtn = (BunifuButton2)sender;

        leftBorderBtn.BackColor = Color.FromArgb(240, 170, 104);
        leftBorderBtn.Location = new Point(0, currentBtn.Location.Y);
        leftBorderBtn.Visible = true;
        leftBorderBtn.BringToFront();

        iconCurrentChildForm.Image = currentBtn.IdleIconLeftImage;
        currentBtn.TextPadding = new Padding(40, 0, 0, 0);
        currentBtn.IconLeftPadding = new Padding(30, 0, 0, 0);
    }
}
private void DisableButton()
{
    if (currentBtn != null)
    {
        currentBtn.TextPadding = new Padding(10, 0, 0, 0);
        currentBtn.IconLeftPadding = new Padding(10, 0, 0, 0);
    }
}
```

Для того, щоб відкрити необхідну форму можна стористатися методом [OpenChildForm](/Practice/UserProfile.cs). Виконується закриття попередньої форми, якщо вона була викликана і продовжується присвоєння силки на об'єкт форми до локальної зміни, в якій відбувається основна робота відповідно до завдання.

```c#
///<param name="childForm">Об'єкт форми, яка належить до даного пункту меню</param>
private void OpenChildForm(Form childForm)
{
    if (currentChildForm != null)
    {
        currentChildForm.Close();
    }
    currentChildForm = childForm;
    childForm.TopLevel = false;
    childForm.FormBorderStyle = FormBorderStyle.None;
    childForm.Dock = DockStyle.Fill;
    bunifuGradientPanelDesktop.Controls.Add(childForm);
    bunifuGradientPanelDesktop.Tag = childForm;
    childForm.BringToFront();
    childForm.Show();
    labelCurrentChildForm.Text = childForm.Text;
}
```

---

## Задача №1

### Умова

Побудувати програму для обчислення:

- значення функціональної суми для формули **<sup>n, ∞</sup>∑<sub>i=0</sub> cos(x \* i) / i!** накопиченої сумою для кількості членів **_i_** від **_1_** до **_n_** додатків;
- значення суми з потрібною точністю **_ℰ = 0,001_**. Знайти також кількість підсумованих при цьому елементів, результати рішення вивести в таблицю та побудувати графік залежності значення суми від кількості підсумованих членів;
- значення функції **y = ℰ<sup>cos x</sup>cos(sin x)**

### Опис

Коли користувач вибирає пункт "_Задача №1_", то перед ним постає вибір виконання заданого завадння. В "_Пункті №1_" можна виконати обчислення функціальної суми, ввівші відповідні дані.

![](https://github.com/BogdanPhoenix/Practica_Course2/raw/master/Images/Task1_Item1_Default.png "Функціональна сума")

В цьому пункті відбувається просте накопичення функціональної суми з вказаною кількістю ітерацій та обчислення функції, яка служить для того, щоб перевірити точність обчислення. Під час введення користувачем даних в аргументі враховані певні обмеження:

- заборона введення символів для аргументу, крім чисел та певних знаків (кома, мінус);
- для кількості ітерецій можна ввести лише числа, всі інші символи є заборонені;
- додані повідомлення про обмеження кількості у відповідні поля ([метод MaxLengthTextBox](/Practice/FormTaskOne.cs)).

![](https://github.com/BogdanPhoenix/Practica_Course2/raw/master/Images/Task1_Item1_Result.png "Функціональна сума після обчислення")

Після виконання завдання користувачу виводить повна інформація:

- формула рівняння;
- формула функції;
- дані, які ввів користувач;
- результат рівняння та функції.

В "_Пункті №2_" відбувається обчислення суми із заданою точністю та побудовою відповідного графіку.

![](https://github.com/BogdanPhoenix/Practica_Course2/raw/master/Images/Task1_Item2_Default.png "Значення суми з потрібною точністю")

Після вибору другого пунку перед користувачем постає поле для введення аргументу та повзунець (_слайдер_), за допомогою якого можна вибрати точність від **_10<sup>-9</sup>_** до **_1_**.

Коли користувач натиснув отримати результат перед ним з'являється відповідна інформація:

- формула рівняння;
- введенні дані (аргумент та вибрана точність);
- результат накописеної суми;
- кількість підсумованих елементів;

![](https://github.com/BogdanPhoenix/Practica_Course2/raw/master/Images/Task1_Item2_Result.png "Значення суми з потрібною точністю після обчислення")

Також користувачу стає доступною кнопка, щоб відкрити/закрити бокову панель для відображення графіку. Після натиску на цю кнопку з'являється/зникає відповідне поле з таблицею даних для графіку та самим графіком.

![](https://github.com/BogdanPhoenix/Practica_Course2/raw/master/Images/Task1_Item2_Graph.png "Графік залежності значення суми від кількості підсумованих членів")

Нижче навелений [фрагмент коду](/Practice/FormTaskOne.cs) який відповідає за виведення повідомлення, якщо користувач достиг максимально дозволеної кількості символів у полів і виводить відповідне повідомлення.

```c#
/// <param name="sender">Об'єкт текстового поля</param>
/// <param name="e">Базовый клас для класів, який містить дані про властивість натиску на клавішу та надає її функціонал</param>
private void MaxLengthTextBox(object sender, KeyPressEventArgs e)
{
    TextBox textBox = (TextBox)sender;
    if (e.KeyChar != (char)Keys.Back && textBox.Text.Length == textBox.MaxLength)
    {
       bunifuSnackbar.Show(ParentForm, $"Ви ввели максимальну кількість символів ({textBox.MaxLength})");
    }
}
```

Даний [метод](/Practice/FormTaskOne.cs) дозволяє за допомогою короткого запису отримати факторіал вказаного числа.

```c#
/// <param name="number">Число для факторіалу</param>
/// <returns>Факторіал вкащаного числа</returns>
private int Fact(int number)
{
    return number == 0 ? 1 : number * Fact(number - 1);
}
```

---

## Задача №2

### Умова

Створити програму для обчислення білінійної форми **_B = m <sup>n</sup>∑<sub>i=1</sub> x<sub>i</sub> <sup>n</sup>∑<sub>k=1</sub> a<sub>ik</sub>y<sub>k</sub>_**, де **_m_** - максимальний елемент вектора **_X_** = (x<sub>1</sub>, x<sub>2</sub>,.. x<sub>n</sub>). Матриця **_A_** = \[a<sub>i,j</sub>]<sub>n\*n</sub>, вектор **_X_** та вектор **_Y_** = (y<sub>1</sub>, y<sub>y</sub>,.. y<sub>n</sub>). задані (n <= 6).

### Опис

![](https://github.com/BogdanPhoenix/Practica_Course2/raw/master/Images/Task2_Default.png "Вигляд поля при виборі даної форми, або її оновленні")

Під час введення даних в матрицю та у вектори виконується перевірка на введені дані та блокуються недопустимі символи.

За допомогою повзунка можна обрати кількість комірок в одновимірних масивах та двовимирній матриці.

![](https://github.com/BogdanPhoenix/Practica_Course2/raw/master/Images/Task2_Result.png "Відображення заповнених даних та виведення результату білінійного рівняння")

Після введення всіх даних та натиску клавіші "Результат" користувачу виводиться формула самого рівняння та результат отриманих обчислення.

---

## Задача №3

### Умова

1. Скласти програму обчислення значень функцій і вивести їх результат у вигляді таблиці.

2. Дослідити способами математичного аналізу поведінку функції свого варіанту при заданих значеннях аргументу. При наявності особливих випадків передбачити в програмі відповідний захист.

3. Для тригонометричних функцій включити значення **_x_**, кратне числу **_π_**.

4. Вивести на екран графіки функції за допомогою підпрограми-процедури.

**Функції до табулювання**

|         Функція №1          |            Функція №2             |              Функція №3              |        Функція №4        |      Функція №5       |        Функція №6         |        Функція №7        |
| :-------------------------: | :-------------------------------: | :----------------------------------: | :----------------------: | :-------------------: | :-----------------------: | :----------------------: |
| $$ 1 \over x^2 (1 - x^4) $$ | $$ x^2 \over \sqrt[3]{1 + x^3} $$ | $$ 1 \over \sqrt[3]{1 - sin^3(x)} $$ | $$ 1 \over x^2e^{x^2} $$ | $$ 1 \over ch^2(x) $$ | $$ x \over ln^2(x - 1) $$ | $$ 1 \over ch(cos(x)) $$ |

### Опис

![](https://github.com/BogdanPhoenix/Practica_Course2/raw/master/Images/Task3_Default.png "Вигляд поля при виборі даної форми, або її оновленні")

При виборі третього пункту перед користувачем з'являється форма з трьома текстовими полями та однією кнопкою для отримання результату. В дані текстові поля можна ввести дані, межі відрізка (**_x<sub>min</sub>_** та **_x<sub>max</sub>_**) та крок (**_h_**), з яким буде здійснювати автоматичне отримання даних для заповнення таблиці.

Для кожного текстового поля встановлено спеціальну маску, яка обмежує введення символів, які заборонено вводити та виводить повідомлення коли було введено максимальну кількість символів.

![](https://github.com/BogdanPhoenix/Practica_Course2/raw/master/Images/Task3_ResultForm.png 'Вигляд поля при натиску на кнопку "Результат"')

Після заповнення всіх текстових полів та натиску на кнопку "Результат" здійснюється обчислення даних для кожної з функцій та отриманий результат заноситься у відповідну комірку. Після обчислення дані в таблиці змінити самостійно - не можливо.

Також після отримання результату з'являється кнопка (справа від таблиці), яка дозволяє відкрити графік вибраної форми. Вибрана форма знаходиться в салатовому квадраті, щоб вибрати якусь іншу форму потрібно натиснути на неї.

![](https://github.com/BogdanPhoenix/Practica_Course2/raw/master/Images/Task3_ResultGraph1.png "Вигляд поля при відкритті поля з відображенням графіку першої функції")

![](https://github.com/BogdanPhoenix/Practica_Course2/raw/master/Images/Task3_ResultGraph2.png "Вигляд поля при відкритті поля з відображенням графіку шостої функції")

Після відображення бокового поля перед користувачем з'явиться графік вибраної функції.

### **Метод для обчислення результату та заповнення таблиці даних**

В даному методі, який розташований у файлі [FormTaskThree.cs](/Practice/FormTaskThree.cs) відбувається обчислення даних в таблиці.

**Етапи виконання даного методу**

1. Здійснюється приховування надпису, який інформує про відсутність даних, та відображення таблиці з майбутніми даними.
2. Очищення попередніх даних, якщо вони були присутні до цього.
3. Отримання меж відрізка (**_x<sub>min</sub>_** та **_x<sub>max</sub>_**) та їхнього кроку (**_h_**), які заносяться у відповідні змінні `min, max, step`.
4. Отримання кількості розрядів числа, які будуть використувуватися для заокруглення кінцевого результату (змінна `dig`).
5. Отримання крайнього лівого значення числа **$\pi$**, яке може зустрітися на даному проміжку. Якщо даний результат дорівнює нулю то в змінні `pi` присвоюється `0,25`, що буде слугувати першим числом **$\pi$**.
6. Після отримання всіх даних відбувається обчислення значень для кожної функції. Виконується перевірка чи поточний аргумент є рівним числу **$\pi$** помножене на відповідний коефіціент. Якщо дане твердження є істинним, то відбувається заповнення лише тих комірок, які відповідають тригонометричним функціям, для всіх інших ставляться прочерки `"-"`. Також здійснюється збільшення коефіцієнта на `0,25`. що відображає наступне загальновживане число **$\pi$**. Якщо дане число не є одним із варіантів числа **$\pi$**, то виконується обчислення для всіх функцій із заданим аргументом.
7. Після завершення заповнення даних викликається метод _`CreateGraph`_ - для побудови графіків (_опис читати нижче_).
8. Відбуваєтья відображення кнопки, яка відкриває бокове меню з графіком, якщо вона до цього була скрита.

```c#
/// <param name="sender">Об'єкт кнопки</param>
/// <param name="e">Базовый клас для класів, який містить дані властивостей та надає їх</param>
private void ButtonResult_Click(object sender, EventArgs e)
{
    labelInfo.Visible = false;
    tableLayoutPanelFunction.Visible = true;
    dataResult.Rows.Clear();
    double min = Convert.ToDouble(minX.Text);
    double max = Convert.ToDouble(maxX.Text);
    double step = Convert.ToDouble(stepX.Text);
    int dig = stepX.Text.Length - stepX.Text.IndexOf(',') - 1;
    double pi = min == 0 ? 0.25 : Math.Ceiling(min / Math.PI);
    for (double i = min; i <= max; i += step)
    {
        i = Math.Round(i, dig);
        if (i != 0 && Math.Round(pi * Math.PI, dig) == i)
        {
            dataResult.Rows.Add($"{pi}π", "-", "-", FunctionThree(pi * Math.PI), "-", FunctionFive(pi * Math.PI), "-", FunctionSeven(pi * Math.PI));
            pi += 0.25;
            i -= step;
            if (pi == 0)
            {
                pi += 0.25;
            }
        }
        else
        {
            dataResult.Rows.Add(i, FunctionOne(i), FunctionTwo(i), FunctionThree(i), FunctionFour(i), FunctionFive(i), FunctionSix(i), FunctionSeven(i));
        }
    }
    CreateGraph(buttonFunction1, new EventArgs());
    if (panelRight.Width == 1)
    {
        panelRight.Width = closeWidthPanelRight;
    }
}
```

### **Метод для створення графіка функції, які залежить від від вибраної функції**

В даному методі, який розташований у файлі [FormTaskThree.cs](/Practice/FormTaskThree.cs) відбувається побудова графіку для вибраної функції.

**Етапи виконання даного методу**

1. Відбувається перевірка чи було побудовано графік до цього. Якщо так, то попередній графік колір фону стає за замовчуванням і текст спливаючої підказки також стає за стандартом.
2. Відбувається присвоєння натиснутої кнопки до змінної, яка відповідає для запам'ятовування попередньо активованої функції.
3. Колір фону замінюється на салатовий і текст спливаючої підказки змінюється на: `'Побудовано графік даної функції'`.
4. Отримання кількості розрядів числа, які будуть використувуватися для заокруглення кінцевого результату (змінна `dig`).
5. Відбувається очищення поля для виведення графіків, щоб можна було побудувати новий графік.
6. Отримання номеру графіку та запам'ятовування його у змінну `index`.
7. Після отримання номеру графіка відбувається вибір відповідної функції, яка буде будувати його. (_Опис функцій наведено нижче_).

```c#
/// <param name="sender">Об'єкт кнопки</param>
/// <param name="e">Базовый клас для класів, який містить дані властивостей та надає їх</param>
private void CreateGraph(object sender, EventArgs e)
{
    if (currentFunction != null)
    {
        currentFunction.BackColor = Color.Transparent;
        bunifuToolTip.SetToolTip(currentFunction, "Натисніть, щоб побудувати графік функції");
    }
    currentFunction = (BunifuImageButton)sender;
    currentFunction.BackColor = Color.FromArgb(102, 204, 51);
    bunifuToolTip.SetToolTip(currentFunction, "Побудовано графік даної функції");

    int dig = stepX.Text.Length - stepX.Text.IndexOf(',') - 1;
    for (int i = 0; i < chart.Series.Count; ++i)
    {
        chart.Series[i].Points.Clear();
    }
    int index = Convert.ToInt32(((BunifuImageButton)sender).Tag.ToString());
    switch (index)
    {
        case 1: GraphOne(dig); break;
        case 2: GraphTwo(dig); break;
        case 3: GraphThree(dig); break;
        case 4: GraphFour(dig); break;
        case 5: GraphFive(dig); break;
        case 6: GraphSix(dig); break;
        case 7: GraphSeven(dig); break;
    }
}
```

### **Метод для побудови графіка**

Методи для побудови графіків майже є однаковими, але відрізняються ОДЗ. Опис буде здійснюватися для методу, який будує графік першої функції.

Створюється дві змінні, `series` - необхідний для тогоЮ щоб вказати компілятору яку пряму використовувати (необхідний для того, щоб на графіку будувалися розрили) та `buffer` в яку поміщується результат конвертації даних з комірки таблиці в дробове число.

Під час кожного разу перевіряється чи значення функції в точці аргументу не дорівнює прочерку. Якщо в даній комірці розташований прочерк `"-"`, то точка не будується. Якщо в комірці розташоване якесь число то продовжується отримання аргументу з таблиці та перевірка цього аргументу на ОДЗ, яке дає змогу визначити яку лінію будувати.

Якщо рівняння є тригонометричним (метод GraphThree), то також виконується перевірка на те, чи аргумент відповідає числу **$\pi$** та після перевірки та отримання істинного результат виконується числове обчислення числа **$\pi$** (метод GetPi).

```c#
/// <summary> Метод для побудови графіка до формули №1 </summary>
/// <param name="dig">Кількість знаків після коми</param>
private void GraphOne(int dig)
{
    int series;
    double buffer;
    for (int i = 0; i < dataResult.RowCount; ++i)
    {
        if (!dataResult.Rows[i].Cells[1].Value.Equals("-"))
        {
            buffer = Math.Round(Convert.ToDouble(dataResult.Rows[i].Cells[0].Value.ToString()), dig);
            if (buffer < -1)
            {
                series = 0;
            }
            else if (buffer < 0)
            {
                series = 1;
            }
            else if (buffer < 1)
            {
                series = 2;
            }
            else
            {
                series = 3;
            }
            chart.Series[series].Points.AddXY(buffer, Math.Round(Convert.ToDouble(dataResult.Rows[i].Cells[1].Value), dig));
        }
    }
}
/// <summary> Метод для побудови графіка до формули №3 </summary>
/// <param name="dig">Кількість знаків після коми</param>
private void GraphThree(int dig)
{
    double buffer;
    for (int i = 0; i < dataResult.RowCount; ++i)
    {
        if (!dataResult.Rows[i].Cells[3].Value.Equals("-"))
        {
            if (dataResult.Rows[i].Cells[0].Value.ToString().EndsWith("π"))
            {
                buffer = GetPi(dataResult.Rows[i].Cells[0].Value.ToString(), dig);
            }
             else
            {
                buffer = Math.Round(Convert.ToDouble(dataResult.Rows[i].Cells[0].Value.ToString()), dig);
            }

            chart.Series[0].Points.AddXY(buffer, Math.Round(Convert.ToDouble(dataResult.Rows[i].Cells[3].Value), dig));
        }
    }
}

```

---

## Задача №4

### Умова задачи

Дано файл _F_, компоненти _u<sub>0</sub>,u<sub>1</sub>,...,u<sub>n</sub>_ якого є послідовними числами Фібоначчі. Одержати у файлі _F_ послідовні числа Фібоначчі _u<sub>0</sub>,u<sub>1</sub>,...,u<sub>n + 1</sub>_

---

## Задача №5

### Умова задачи

Дана дійсна прямокуна матриця _A = \[a<sub>ij</sub>\]<sub>m\*n</sub>_. Побудувати програму, що має головний модуль та підпрограми перестановки сатриці без зменшення кількості позитивних елементів стовпців.

---

## Маска для текстових полів
